From 7bcbb37e2b443d417f073c4821b67156ef83915f Mon Sep 17 00:00:00 2001
From: Thomas Frauendorfer <tf@miray.de>
Date: Wed, 7 May 2014 15:13:26 +0200
Subject: [PATCH 22/41] Miray emergency boot log

---
 grub-core/Makefile.am              |   1 +
 grub-core/Makefile.miray.def       |   7 +
 grub-core/kern/efi/mm.c            |  75 ++++++
 grub-core/kern/i386/pc/init.c      |  55 ++++
 grub-core/miray/bootlog/README.txt |   2 +
 grub-core/miray/bootlog/bootlog.c  | 501 +++++++++++++++++++++++++++++++++++++
 include/grub/miray_bootlog.h       |  63 +++++
 7 files changed, 704 insertions(+)
 mode change 100644 => 100755 grub-core/Makefile.am
 mode change 100644 => 100755 grub-core/kern/efi/mm.c
 mode change 100644 => 100755 grub-core/kern/i386/pc/init.c
 create mode 100755 grub-core/miray/bootlog/README.txt
 create mode 100755 grub-core/miray/bootlog/bootlog.c
 create mode 100755 include/grub/miray_bootlog.h

diff --git a/grub-core/Makefile.am b/grub-core/Makefile.am
old mode 100644
new mode 100755
index 5c087c8..453978e
--- a/grub-core/Makefile.am
+++ b/grub-core/Makefile.am
@@ -87,6 +87,7 @@ if !COND_clang
 KERNEL_HEADER_FILES += $(top_srcdir)/include/grub/libgcc.h
 endif
 KERNEL_HEADER_FILES += $(top_srcdir)/include/grub/memory.h
+KERNEL_HEADER_FILES += $(top_srcdir)/include/grub/miray_bootlog.h
 
 if COND_i386_pc
 KERNEL_HEADER_FILES += $(top_builddir)/include/grub/machine/kernel.h
diff --git a/grub-core/Makefile.miray.def b/grub-core/Makefile.miray.def
index 9d2b9ea..bc410cd 100755
--- a/grub-core/Makefile.miray.def
+++ b/grub-core/Makefile.miray.def
@@ -28,6 +28,13 @@ module = {
 
 
 
+module = {
+  name = miray_bootlog;
+  common = miray/bootlog/bootlog.c;
+};
+
+
+
 module = { 
   name = miray_activity;
   common = miray/lib/activity.c;
diff --git a/grub-core/kern/efi/mm.c b/grub-core/kern/efi/mm.c
old mode 100644
new mode 100755
index be37afd..92b7d78
--- a/grub-core/kern/efi/mm.c
+++ b/grub-core/kern/efi/mm.c
@@ -22,6 +22,7 @@
 #include <grub/efi/api.h>
 #include <grub/efi/efi.h>
 #include <grub/cpu/efi/memory.h>
+#include <grub/miray_bootlog.h>
 
 #if defined (__i386__) || defined (__x86_64__)
 #include <grub/pci.h>
@@ -49,6 +50,11 @@ static grub_efi_uintn_t finish_desc_size;
 static grub_efi_uint32_t finish_desc_version;
 int grub_efi_is_finished = 0;
 
+#ifdef USE_MIRAY_BOOTLOG
+static void * miray_bootlog_addr = 0;
+static grub_size_t miray_bootlog_size = 0;
+#endif
+
 /* Allocate pages. Return the pointer to the first of allocated pages.  */
 void *
 grub_efi_allocate_pages (grub_efi_physical_address_t address,
@@ -481,6 +487,53 @@ grub_efi_mm_init (void)
 
   memory_map_end = NEXT_MEMORY_DESCRIPTOR (memory_map, map_size);
 
+#ifdef USE_MIRAY_BOOTLOG
+  {
+    static const grub_size_t pages_needed = BYTES_TO_PAGES(MIRAY_BOOTLOG_SIZE);
+    grub_efi_memory_descriptor_t *desc;
+    //grub_efi_memory_descriptor_t *best_desc = 0;
+    grub_efi_physical_address_t best_addr = 0;
+    grub_size_t best_count = 0; // Count in pages
+
+    for (desc = memory_map;
+         desc < memory_map_end;
+         desc = NEXT_MEMORY_DESCRIPTOR (desc, desc_size))
+      {
+        if (desc->type == GRUB_EFI_CONVENTIONAL_MEMORY && desc->physical_start <= 0xffffffffULL)
+        {
+#if 0
+           if (((best_count < pages_needed) && (desc->num_pages > best_count)) ||
+               ((best_addr < desc->physical_start) && ((desc->physical_start + MIRAY_BOOTLOG_SIZE) <= 0xffffffffULL)  && (desc->num_pages >= pages_needed)))
+           {
+              best_count = (desc->num_pages < pages_needed) ? desc->num_pages : pages_needed;
+              best_addr  = desc->physical_start + PAGES_TO_BYTES(desc->num_pages - best_count);
+              //best_desc = desc;
+           }
+#endif    
+           if ((best_addr < desc->physical_start) && ((desc->physical_start + MIRAY_BOOTLOG_SIZE) <= 0xffffffffULL)  && (desc->num_pages >= pages_needed + PAGES_TO_BYTES(1024 * 1024)))
+           {
+              best_count = pages_needed;
+              //best_addr  = desc->physical_start + PAGES_TO_BYTES(desc->num_pages - best_count);
+              best_addr = desc->physical_start;
+           }
+
+        }
+      }
+
+      if (best_addr != 0 && best_count != 0)
+      {
+         miray_bootlog_addr = grub_efi_allocate_pages(best_addr, best_count);
+         miray_bootlog_size = PAGES_TO_BYTES(best_count);
+         map_size = MEMORY_MAP_SIZE;
+         mm_status = grub_efi_get_memory_map (&map_size, memory_map, 0,
+					      &desc_size, 0);
+
+         memory_map_end = NEXT_MEMORY_DESCRIPTOR (memory_map, map_size);
+      }
+  }  
+#endif
+
+
   filtered_memory_map = memory_map_end;
 
   filtered_memory_map_end = filter_memory_map (memory_map, filtered_memory_map,
@@ -520,3 +573,25 @@ grub_efi_mm_init (void)
   grub_efi_free_pages ((grub_addr_t) memory_map,
 		       2 * BYTES_TO_PAGES (MEMORY_MAP_SIZE));
 }
+
+
+#ifdef USE_MIRAY_BOOTLOG
+grub_err_t miray_getBootlogHeader(void ** addr __attribute__((unused)), grub_size_t * size __attribute__((unused)))
+{
+   if (addr == 0 || size == 0)
+   {
+      return grub_error(GRUB_ERR_BUG, "Invalid data");
+   }
+
+   if (miray_bootlog_addr == 0)
+   {
+      return grub_error(GRUB_ERR_BUG, "No memory");
+   }
+
+   *addr = miray_bootlog_addr;
+   *size = miray_bootlog_size;
+
+
+   return GRUB_ERR_NONE;
+}
+#endif
diff --git a/grub-core/kern/i386/pc/init.c b/grub-core/kern/i386/pc/init.c
old mode 100644
new mode 100755
index 3c8160a..b3f0f2f
--- a/grub-core/kern/i386/pc/init.c
+++ b/grub-core/kern/i386/pc/init.c
@@ -34,6 +34,7 @@
 #include <grub/time.h>
 #include <grub/cpu/tsc.h>
 #include <grub/machine/time.h>
+#include <grub/miray_bootlog.h>
 
 struct mem_region
 {
@@ -48,6 +49,11 @@ static int num_regions;
 
 void (*grub_pc_net_config) (char **device, char **path);
 
+#ifdef USE_MIRAY_BOOTLOG
+static grub_addr_t miray_bootlog_addr = 0;
+static grub_size_t miray_bootlog_size = 0;
+#endif
+
 /*
  *	return the real time in ticks, of which there are about
  *	18-20 per second
@@ -223,6 +229,33 @@ grub_machine_init (void)
 
   compact_mem_regions ();
 
+#ifdef USE_MIRAY_BOOTLOG
+  // Reserve or search space for miray boot log.
+  // At the moment we place it at the end of the last region that is big enough
+
+  for (i = num_regions - 1; i >= 0; i--)
+  {
+    if (mem_regions[i].addr >= 0x7fffffffULL) // Place data below 2GB, calculation below chokes otherwise.
+      continue;
+
+     /* Make sure that the memory region we use for the emergency log has at least 1MB left.
+      * GRUB memory management cannot handle it if it gets an empty memory region (size 0),
+      * and it might also have problems with small regions. 1 MB is not really a problem and
+      * finding out the exact min size would take quite long and it would also be unnecessary.
+      * Furthermore, the min size might change with the next update.
+      */ 
+    if (mem_regions[i].size - (mem_regions[i].addr & 0xfff) >= (MIRAY_BOOTLOG_SIZE + 1024 * 1024))
+    {
+      // Found it
+      miray_bootlog_addr = ((mem_regions[i].addr + mem_regions[i].size - MIRAY_BOOTLOG_SIZE) & ~(0xfffUL));
+      miray_bootlog_size = MIRAY_BOOTLOG_SIZE;
+      mem_regions[i].size = miray_bootlog_addr - mem_regions[i].addr;
+
+      break;
+    }
+  }
+#endif
+
   modend = grub_modules_get_end ();
   for (i = 0; i < num_regions; i++)
     {
@@ -245,3 +278,25 @@ grub_machine_fini (int flags)
     grub_console_fini ();
   grub_stop_floppy ();
 }
+
+
+#ifdef USE_MIRAY_BOOTLOG
+grub_err_t miray_getBootlogHeader(void ** addr, grub_size_t * size)
+{
+   if (addr == 0 || size == 0)
+   {
+      return grub_error(GRUB_ERR_BUG, "Invalid data");
+   }
+
+   if (miray_bootlog_addr == 0)
+   {
+      return grub_error(GRUB_ERR_BUG, "No memory");
+   }
+
+   *addr = (void *)miray_bootlog_addr;
+   *size = miray_bootlog_size;
+
+
+   return GRUB_ERR_NONE;
+}
+#endif
diff --git a/grub-core/miray/bootlog/README.txt b/grub-core/miray/bootlog/README.txt
new file mode 100755
index 0000000..4a69456
--- /dev/null
+++ b/grub-core/miray/bootlog/README.txt
@@ -0,0 +1,2 @@
+Helper module to reserve memory to save a log to and store it to a
+preallocated file on the disk 
diff --git a/grub-core/miray/bootlog/bootlog.c b/grub-core/miray/bootlog/bootlog.c
new file mode 100755
index 0000000..aacaf2c
--- /dev/null
+++ b/grub-core/miray/bootlog/bootlog.c
@@ -0,0 +1,501 @@
+/* bootlog.c - prepare memory for logging or sync it after reboot */
+/*
+ *  GRUB  --  GRand Unified Bootloader
+ *  Copyright (C) 2000,2001,2002,2003,2005,2006,2007,2008,2009  Free Software Foundation, Inc.
+ *  Copyright (C) 2010,2011,2012 Miray Software <oss@miray.de>
+ *
+ *  GRUB is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  GRUB is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with GRUB.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <grub/memory.h>
+#include <grub/machine/memory.h>
+#include <grub/dl.h>
+#include <grub/misc.h>
+#include <grub/command.h>
+#include <grub/miray_bootlog.h>
+#include <grub/extcmd.h>
+#include <grub/file.h>
+#include <grub/mm.h>
+#include <grub/env.h>
+#include <grub/device.h>
+#include <grub/disk.h>
+#include <grub/partition.h>
+
+GRUB_MOD_LICENSE ("GPLv3+");
+
+static const grub_uint64_t bootlog_min_size = sizeof(struct mirayBootlogHeader);
+
+
+struct log_blocklist
+{
+  grub_disk_addr_t startsector;
+  unsigned offset;
+  grub_uint64_t length;
+  struct log_blocklist *next;
+   
+};
+
+static grub_file_t
+open_bootlog_file (const char *filename)
+{
+   // TODO: handle case without filename?
+
+   
+   grub_file_filter_disable_compression ();
+   return grub_file_open (filename);
+}
+
+struct read_hook_data
+{
+   struct log_blocklist * head;
+   struct log_blocklist * tail;
+   unsigned sectorSize;
+};
+
+static void read_hook (grub_disk_addr_t sector, unsigned offset, unsigned length, void * data)
+{
+   struct read_hook_data * hook_data = (struct read_hook_data *)data;
+   
+   if (hook_data->tail != 0 && hook_data->tail->startsector * hook_data->sectorSize + hook_data->tail->offset + hook_data->tail->length == sector * hook_data->sectorSize + offset)
+   {
+      hook_data->tail->length += length;
+   }
+   else
+   {
+      // Add new entry
+      struct log_blocklist * new = (struct log_blocklist *)grub_malloc(sizeof(struct log_blocklist));
+      new->startsector = sector;
+      new->offset = offset;
+      new->length = length;
+      new->next = 0;
+
+      if (hook_data->tail != 0)
+         hook_data->tail->next = new;
+      hook_data->tail = new;
+      if (hook_data->head == 0)
+      {
+         hook_data->head = new;
+      }
+   }
+}
+
+
+static struct log_blocklist *
+file_get_blocks(grub_file_t file)
+{
+   struct read_hook_data data = { .head = 0, .tail = 0 };
+   grub_uint8_t * buffer = 0;
+
+   if (file == 0)
+   {
+      grub_error(GRUB_ERR_BAD_ARGUMENT, "file == 0");
+      return 0;
+   }
+
+   if (!file->device->disk)
+   {
+      grub_error (GRUB_ERR_BAD_DEVICE, "disk device required");
+      return 0;
+   }
+
+   data.sectorSize = 1 << file->device->disk->log_sector_size;
+   if (data.sectorSize < 512 || data.sectorSize > 4096)
+   {
+      grub_error (GRUB_ERR_BAD_DEVICE, "Invalid sector size %d", data.sectorSize);
+      return 0;
+   }
+
+
+   buffer = grub_malloc(data.sectorSize);
+
+   file->read_hook = read_hook;
+   file->read_hook_data = &data;
+   while (grub_file_read(file, buffer, data.sectorSize) > 0)
+   {
+   }
+   grub_free(buffer);
+   file->read_hook = 0;
+   file->read_hook_data = 0;
+   
+   return data.head;
+}
+
+static void
+free_blocklist(struct log_blocklist * list)
+{
+   struct log_blocklist * next = list;
+
+   while (list != 0)
+   {
+      next = list->next;
+      grub_free(list);
+      list = next;
+   }
+}
+   
+#if 0
+static grub_err_t
+miray_cmd_bootlog_test(struct grub_command *cmd __attribute__ ((unused)),
+      int argc __attribute__((unused)), char * argv[] __attribute__((unused)))
+{
+   grub_file_t file = 0;
+   struct log_blocklist * list = 0;
+
+   if (argc < 1)
+      return grub_error(GRUB_ERR_BAD_ARGUMENT, "missing filename");
+
+   file = grub_file_open (argv[0]);
+
+   if (file == 0)
+      return grub_error(GRUB_ERR_FILE_NOT_FOUND, "No such file");
+
+  if (! file->device->disk)
+    {
+      grub_file_close (file);
+      return grub_error (GRUB_ERR_BAD_DEVICE, "disk device required");
+    }
+
+   list = file_get_blocks(file);
+   if (list != 0)
+   {
+      struct log_blocklist * current = list;
+      while (current != 0)
+      {
+         grub_printf("sector = 0x%" PRIxGRUB_UINT64_T ", offset = %d, length = 0x%" PRIxGRUB_UINT64_T "\n", current->startsector, current->offset, current->length);
+         current = current->next;
+      }
+   }
+
+   free_blocklist(list);
+
+   grub_file_close(file);
+
+   
+   return GRUB_ERR_NONE;
+}
+#endif
+
+static const struct grub_arg_option options_bootlog_activate[] =
+{
+   {"set",             's', 0,
+      ("Set a variable to return value."), "VAR", ARG_TYPE_STRING},
+   {"file", 'f', 0,
+      ("Filename to limit max size"), "VAR", ARG_TYPE_STRING},
+   {0, 0, 0, 0, 0, 0}
+};
+
+static grub_err_t
+miray_cmd_bootlog_activate(grub_extcmd_context_t ctxt,
+      int argc __attribute__((unused)), char * argv[] __attribute__((unused)))
+{
+   struct grub_arg_list *state = ctxt->state;
+
+   struct mirayBootlogHeader * header = 0;
+   grub_uint64_t filesize = -1ULL;
+   grub_size_t size = 0;
+
+   grub_err_t ret;
+
+   if (!state[0].set)
+   {
+      return grub_error(GRUB_ERR_BAD_ARGUMENT, "Missing environment name");
+   }
+
+   if (state[1].set)
+   {
+      grub_file_t file = grub_file_open (state[1].arg);
+      if (file != 0)
+      {
+         filesize = grub_file_size(file);
+         grub_file_close(file);
+      }
+   }
+
+   if (filesize < bootlog_min_size)
+   {
+      return grub_error(GRUB_ERR_BAD_ARGUMENT, "Logfile too small");
+   }
+
+   ret = miray_getBootlogHeader((void **)&header, &size);
+   if (ret != GRUB_ERR_NONE)
+      return ret;
+
+   filesize = filesize & (~(GRUB_DISK_SECTOR_SIZE - 1)); // TODO: Use disk block size?
+
+   header->addr = (grub_uint64_t)(unsigned long)header;
+   header->memsize = (filesize < size) ? filesize : size;
+   header->datasize = 0; 
+   grub_memmove(header->magic, mirayBootlogMemMagic, MIRAY_BOOTLOG_MAGIC_SIZE);
+   grub_memset(miray_bootlog_dataAddr(header), ' ', miray_bootlog_memSize(header));
+
+
+   // Mark memory as unavailable (HOLE)
+   // Actually this should not be necessary, but we want to make sure it works
+   { 
+      char str_from[20];
+      char str_to[20];
+      char *func_args[] = { str_from, str_to };
+
+      grub_snprintf(str_from, 20, "%" PRIuGRUB_UINT64_T, header->addr);
+      grub_snprintf(str_to, 20, "%" PRIuGRUB_UINT64_T, header->addr + header->memsize - 1);
+      
+      grub_command_execute("cutmem", 2, func_args);
+   }
+
+   // Write the environment variable
+   {
+      #define ACTIVATE_MAX_STRING 50
+      char tmp[ACTIVATE_MAX_STRING + 1];
+      grub_snprintf(tmp, ACTIVATE_MAX_STRING, "0x%" PRIxGRUB_UINT64_T ",0x%" PRIxGRUB_UINT64_T, header->addr, header->memsize);
+      tmp[ACTIVATE_MAX_STRING] = '\0';
+      #undef ACTIVATE_MAX_STRING
+
+      grub_env_set(state[0].arg, tmp);
+   }
+
+   grub_errno = GRUB_ERR_NONE;
+   return GRUB_ERR_NONE;
+}
+
+static grub_err_t
+miray_cmd_bootlog_has_log(struct grub_command *cmd __attribute__ ((unused)),
+      int argc __attribute__((unused)), char * argv[] __attribute__((unused)))
+{
+   struct mirayBootlogHeader * header = 0;
+   grub_size_t size = 0;
+
+   grub_err_t ret;
+
+   ret = miray_getBootlogHeader((void **)&header, &size);
+   if (ret != GRUB_ERR_NONE)
+   {
+      return ret;
+   }
+
+   if (grub_memcmp(header->magic, mirayBootlogLogMagic, MIRAY_BOOTLOG_MAGIC_SIZE) != 0)
+   {
+      return grub_error(GRUB_ERR_BUG, "Invalid header");
+   }
+
+   if (header->datasize == 0)
+   {
+      return grub_error(GRUB_ERR_BUG, "No data available");
+   }
+
+   grub_errno = GRUB_ERR_NONE;
+   return GRUB_ERR_NONE;
+}
+      
+static const struct grub_arg_option options_bootlog_write[] =
+{
+   {"file",             'f', 0,
+      ("destination file"), "VAR", ARG_TYPE_STRING},
+   {0, 0, 0, 0, 0, 0}
+};
+
+static grub_err_t
+miray_cmd_bootlog_write(grub_extcmd_context_t ctxt,
+      int argc __attribute__((unused)), char * argv[] __attribute__((unused)))
+{
+   struct grub_arg_list *state = ctxt->state;
+
+   struct mirayBootlogHeader * header = 0;
+   grub_size_t size = 0;
+
+   grub_file_t file = 0;
+   grub_size_t writesize = 0;
+   grub_disk_addr_t part_start = 0;
+   struct log_blocklist * blist = 0;
+
+
+   grub_err_t ret;
+
+   if (!state[0].set)
+   {
+      return grub_error(GRUB_ERR_BAD_ARGUMENT, "Missing filename");
+   }
+
+   ret = miray_getBootlogHeader((void **)&header, &size);
+   if (ret != GRUB_ERR_NONE)
+      return ret;
+
+   file = open_bootlog_file(state[0].arg);
+   if (file == 0)
+   {
+      return grub_errno; /* File open has already set the error number */
+   }
+
+   /* Little bit of tricky calculation. Essentially write out data rounded up to SECTOR size, up to file size truncated to sector size */
+   writesize = (((header->datasize + GRUB_DISK_SECTOR_SIZE <= grub_file_size(file)) ?  header->datasize + GRUB_DISK_SECTOR_SIZE : grub_file_size(file))) & (~(GRUB_DISK_SECTOR_SIZE - 1));
+
+   if (writesize < bootlog_min_size)
+   {
+      return grub_error(GRUB_ERR_BAD_ARGUMENT, "File too small");
+   }
+
+   if (!file->device->disk)
+   {
+      grub_file_close (file);
+      return grub_error (GRUB_ERR_BAD_DEVICE, "disk device required");
+   }
+
+   blist = file_get_blocks(file);
+   if (blist == 0)
+   {
+      grub_file_close(file);
+      return grub_errno;
+   }
+
+   part_start = grub_partition_get_start (file->device->disk->partition);
+
+
+#if 0
+   {
+      grub_uint8_t tmp_buffer[GRUB_DISK_SECTOR_SIZE];
+      grub_memcpy(tmp_buffer, header, GRUB_DISK_SECTOR_SIZE);
+      grub_memset(tmp_buffer, ' ', sizeof(struct mirayBootlogHeader));
+      
+      grub_disk_write(file->device->disk, blist->startsector - part_start, blist->offset, GRUB_DISK_SECTOR_SIZE, tmp_buffer);
+   }
+
+   {
+      struct log_blocklist * curlist = blist;
+      grub_size_t curPos = GRUB_DISK_SECTOR_SIZE;
+      grub_size_t pos = GRUB_DISK_SECTOR_SIZE;
+      grub_uint8_t * buffer = (grub_uint8_t *) header;
+      unsigned sectorSize = 1 << file->device->disk->log_sector_size;
+
+      if (curPos >= curlist->length)
+      {
+         curlist = curlist->next;
+         curPos = 0;
+      }
+
+
+      while (curlist != 0 && pos < writesize)
+      {
+         grub_disk_write(file->device->disk, curlist->startsector - part_start + ((curlist->offset + curPos) / sectorSize), (curlist->offset + curPos) % sectorSize, GRUB_DISK_SECTOR_SIZE, &buffer[pos]);
+         curPos += GRUB_DISK_SECTOR_SIZE;
+         pos += GRUB_DISK_SECTOR_SIZE;
+
+         if (curPos >= curlist->length)
+         {
+            curlist = curlist->next;
+            curPos = 0;
+         }
+      }      
+   }
+   #endif
+
+   {
+   }
+
+   {
+      grub_uint8_t tmp_buffer[GRUB_DISK_SECTOR_SIZE];
+
+      struct log_blocklist * curlist = blist;
+      grub_size_t curPos = GRUB_DISK_SECTOR_SIZE;
+      grub_size_t pos = GRUB_DISK_SECTOR_SIZE;
+      grub_uint8_t * buffer = (grub_uint8_t *) header;
+      unsigned sectorSize = 1 << file->device->disk->log_sector_size;
+      grub_size_t file_size = grub_file_size(file);
+
+
+      grub_memcpy(tmp_buffer, header, GRUB_DISK_SECTOR_SIZE);
+      grub_memset(tmp_buffer, ' ', sizeof(struct mirayBootlogHeader));
+      
+      grub_disk_write(file->device->disk, blist->startsector - part_start, blist->offset, GRUB_DISK_SECTOR_SIZE, tmp_buffer);
+      grub_memset(tmp_buffer, ' ', GRUB_DISK_SECTOR_SIZE);
+
+
+      if (curPos >= curlist->length)
+      {
+         curlist = curlist->next;
+         curPos = 0;
+      }
+
+
+      while (curlist != 0 && pos < file_size)
+      {
+         if (pos < writesize)
+         {
+            grub_disk_write(file->device->disk, curlist->startsector - part_start + ((curlist->offset + curPos) / sectorSize), (curlist->offset + curPos) % sectorSize, GRUB_DISK_SECTOR_SIZE, &buffer[pos]);
+         }
+         else
+         {
+            // Fill remaining file with ' '
+            grub_disk_write(file->device->disk, curlist->startsector - part_start + ((curlist->offset + curPos) / sectorSize), (curlist->offset + curPos) % sectorSize, GRUB_DISK_SECTOR_SIZE, tmp_buffer);
+         }
+
+         curPos += GRUB_DISK_SECTOR_SIZE;
+         pos += GRUB_DISK_SECTOR_SIZE;
+
+         if (curPos >= curlist->length)
+         {
+            curlist = curlist->next;
+            curPos = 0;
+         }
+      }      
+   }
+
+   
+
+   free_blocklist(blist);
+   grub_file_close(file);
+   
+   return GRUB_ERR_NONE;
+}
+
+static grub_extcmd_t cmd_activate;
+static grub_extcmd_t cmd_write;
+static grub_command_t cmd_has_log;
+
+//static grub_command_t cmd_test;
+
+
+GRUB_MOD_INIT(miray_bootlog)
+{
+  cmd_activate = grub_register_extcmd("miray_bootlog_activate",
+                                       miray_cmd_bootlog_activate, 0,
+                                       N_("-s envname"),
+                                       N_("Activate bootlog"),
+                                       options_bootlog_activate);
+
+  cmd_write = grub_register_extcmd("miray_bootlog_write",
+                                     miray_cmd_bootlog_write, 0,
+                                     N_("-f FILE"),
+                                     N_("Write bootlog to disk"),
+                                     options_bootlog_write);
+
+  cmd_has_log = grub_register_command("miray_bootlog_has_log",
+				      miray_cmd_bootlog_has_log, 
+				      0, N_("test if an previous log exists"));
+
+#if 0
+  cmd_test = grub_register_command("miray_bootlog_test",
+				      miray_cmd_bootlog_test, 
+				      0, N_("temporary test for bootlog"));
+#endif
+   
+}
+
+GRUB_MOD_FINI(miray_bootlog)
+{
+  grub_unregister_extcmd (cmd_activate);
+  grub_unregister_extcmd (cmd_write);
+  grub_unregister_command(cmd_has_log);
+  
+  //grub_unregister_command (cmd_test);
+}
+
diff --git a/include/grub/miray_bootlog.h b/include/grub/miray_bootlog.h
new file mode 100755
index 0000000..5ba7d19
--- /dev/null
+++ b/include/grub/miray_bootlog.h
@@ -0,0 +1,63 @@
+/* miray_bootlog.h - prepare memory for logging or sync it after reboot */
+/*
+ *  GRUB  --  GRand Unified Bootloader
+ *  Copyright (C) 2000,2001,2002,2003,2005,2006,2007,2008,2009  Free Software Foundation, Inc.
+ *  Copyright (C) 2010,2011,2012 Miray Software <oss@miray.de>
+ *
+ *  GRUB is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  GRUB is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with GRUB.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <grub/types.h>
+#include <grub/symbol.h>
+#include <grub/err.h>
+
+#ifndef MIRAY_BOOTLOG_HEADER
+#define MIRAY_BOOTLOG_HEADER  1
+
+#define USE_MIRAY_BOOTLOG 1 // More or less easy way to disable the bootlog code again
+
+#ifdef USE_MIRAY_BOOTLOG
+
+#define MIRAY_BOOTLOG_SIZE_SHIFT 20 // Reserve 2^20 Bytes (1 MB) for now 
+#define MIRAY_BOOTLOG_SIZE (1ULL << MIRAY_BOOTLOG_SIZE_SHIFT)
+
+#define MIRAY_BOOTLOG_MAGIC_SIZE 8
+
+static const grub_uint8_t  mirayBootlogMemMagic[MIRAY_BOOTLOG_MAGIC_SIZE] = "BTLOGMEM"; // Memspace has been initialized
+static const grub_uint8_t  mirayBootlogLogMagic[MIRAY_BOOTLOG_MAGIC_SIZE] = "BTLOGDTA"; // Bootlog with data
+
+struct mirayBootlogHeader
+{
+   grub_uint8_t  magic[MIRAY_BOOTLOG_MAGIC_SIZE];
+   grub_uint64_t addr;
+   grub_uint64_t memsize;
+   grub_uint64_t datasize;
+} __attribute__ ((packed));
+
+grub_err_t EXPORT_FUNC(miray_getBootlogHeader)(void ** data, grub_size_t * size);
+
+static inline void * miray_bootlog_dataAddr(const struct mirayBootlogHeader * header)
+{
+   return &((grub_uint8_t *)(grub_addr_t)(header->addr))[sizeof(struct mirayBootlogHeader)];
+}
+
+static inline grub_size_t miray_bootlog_memSize(const struct mirayBootlogHeader * header)
+{
+   return header->memsize - sizeof(struct mirayBootlogHeader);
+}
+
+
+#endif
+
+#endif
-- 
1.9.2.msysgit.0

