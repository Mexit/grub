From 9ea346aa4464473178cd13570fc49ffcabcbeb1d Mon Sep 17 00:00:00 2001
From: Thomas Frauendorfer <tf@miray.de>
Date: Wed, 7 May 2014 16:42:11 +0200
Subject: [PATCH 27/41] helper methods to analyze boot problems

---
 grub-core/Makefile.miray.def              |  12 ++
 grub-core/miray/commands/diag.c           |  95 ++++++++++++++
 grub-core/miray/commands/diag_bios.c      | 204 ++++++++++++++++++++++++++++++
 grub-core/miray/commands/diag_efi.c       | 120 ++++++++++++++++++
 grub-core/miray/commands/miray_cmd_diag.h |  34 +++++
 5 files changed, 465 insertions(+)
 create mode 100755 grub-core/miray/commands/diag.c
 create mode 100755 grub-core/miray/commands/diag_bios.c
 create mode 100755 grub-core/miray/commands/diag_efi.c
 create mode 100755 grub-core/miray/commands/miray_cmd_diag.h

diff --git a/grub-core/Makefile.miray.def b/grub-core/Makefile.miray.def
index 15a65b2..16e701b 100755
--- a/grub-core/Makefile.miray.def
+++ b/grub-core/Makefile.miray.def
@@ -108,6 +108,18 @@ module = {
 
 
 
+module = { 
+  name = miray_diag;
+  common = miray/commands/diag.c;
+  common = lib/hexdump.c;
+
+  i386_pc = miray/commands/diag_bios.c;
+  efi = miray/commands/diag_efi.c;
+  efi = miray/lib/efi.c;
+};
+
+
+
 module = {
   name = miray_bootlog;
   common = miray/bootlog/bootlog.c;
diff --git a/grub-core/miray/commands/diag.c b/grub-core/miray/commands/diag.c
new file mode 100755
index 0000000..120cfca
--- /dev/null
+++ b/grub-core/miray/commands/diag.c
@@ -0,0 +1,95 @@
+/*
+ *  GRUB  --  GRand Unified Bootloader
+ *  Copyright (C) 2010-2012 Miray Software <oss@miray.de>
+ *
+ *  GRUB is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  GRUB is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with GRUB.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include "miray_cmd_diag.h"
+
+#include <grub/dl.h>
+#include <grub/misc.h>
+#include <grub/i18n.h>
+
+#include <multiboot.h>
+
+#ifndef offsetof
+#define offsetof(s, m)  ((grub_size_t)&((s*)0)->m)
+#endif
+
+GRUB_MOD_LICENSE ("GPLv3+");
+
+static grub_err_t
+miray_cmd_test_bootstruct(grub_command_t cmd __attribute__ ((unused)),
+		       int argc __attribute__ ((unused)), char **args __attribute__ ((unused)) )
+{
+   grub_printf("Size of multiboot struct: %" PRIuGRUB_SIZE "\n", sizeof(struct multiboot_info));
+   
+   grub_printf("Offset of fb type: %" PRIuGRUB_SIZE "\n", offsetof(struct multiboot_info, framebuffer_type));
+   grub_printf("Offset of fb palette address: %" PRIuGRUB_SIZE "\n", offsetof(struct multiboot_info, framebuffer_palette_addr));
+   grub_printf("offset of fb red field: %" PRIuGRUB_SIZE "\n", offsetof(struct multiboot_info, framebuffer_red_field_position));
+
+   return 0;
+} 
+
+static grub_command_t cmd_test_bootstruct;
+
+#if defined(GRUB_MACHINE_PCBIOS)
+static grub_command_t cmdcd_bios;
+static grub_command_t cmdhd_bios;
+#endif
+
+#if defined(GRUB_MACHINE_EFI)
+static grub_command_t cmdimg_efi;
+static grub_command_t cmddev_efi;
+#endif
+
+GRUB_MOD_INIT(miray_diag)
+{
+  cmd_test_bootstruct = grub_register_command ("miray_bootstruct_offsets",
+                  miray_cmd_test_bootstruct,
+                  0, N_("Print int 13 ah=0x412 result"));
+
+
+#if defined(GRUB_MACHINE_PCBIOS)
+  cmdhd_bios = grub_register_command ("miray_hdextinfo_bios",
+                  miray_cmd_diag_bios_print_hdextinfo,
+                  0, N_("Print int 13 ah=0x412 result"));
+
+  cmdcd_bios = grub_register_command ("miray_cdinfo_bios",
+                  miray_cmd_diag_bios_print_cdinfo,
+				      0, N_("Print int 13 0x4B01 result"));
+#endif  
+
+#if defined(GRUB_MACHINE_EFI)
+  cmdimg_efi = grub_register_command ("miray_image_path",
+                  miray_cmd_diag_efi_print_image_path,
+				      0, N_("Print loaded image path"));
+  cmddev_efi = grub_register_command ("miray_device_path",
+                  miray_cmd_diag_efi_print_device_path,
+				      0, N_("Print device path for device"));
+#endif
+}
+
+GRUB_MOD_FINI(miray_diag)
+{
+  grub_unregister_command (cmd_test_bootstruct);
+#if defined(GRUB_MACHINE_PCBIOS)
+  grub_unregister_command (cmdcd_bios);
+  grub_unregister_command (cmdhd_bios);
+#elif defined(GRUB_MACHINE_EFI)
+  grub_unregister_command (cmdimg_efi);
+  grub_unregister_command (cmddev_efi);
+#endif
+}
diff --git a/grub-core/miray/commands/diag_bios.c b/grub-core/miray/commands/diag_bios.c
new file mode 100755
index 0000000..3ed5219
--- /dev/null
+++ b/grub-core/miray/commands/diag_bios.c
@@ -0,0 +1,204 @@
+/*
+ *  GRUB  --  GRand Unified Bootloader
+ *  Copyright (C) 2010-2012 Miray Software <oss@miray.de>
+ *
+ *  GRUB is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  GRUB is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with GRUB.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include "miray_cmd_diag.h"
+
+#include <grub/misc.h>
+
+#include <grub/i386/pc/memory.h>
+#include <grub/i386/pc/biosdisk.h>
+#include <grub/i386/pc/int.h>
+#include <grub/lib/hexdump.h>
+
+static int driveno(const char *str)
+{
+  if (*str == '(')
+    str++;
+  if ((str[0] == 'f' || str[0] == 'h') && str[1] == 'd')
+    {
+      grub_uint8_t bios_num = (str[0] == 'h') ? 0x80 : 0x00;
+      unsigned long drivenum = grub_strtoul (str + 2, 0, 0);
+      if (grub_errno == GRUB_ERR_NONE && drivenum < 128)
+        {
+          bios_num |= drivenum;
+          return bios_num;
+        }
+    }
+
+  return -1;
+}
+
+
+
+
+grub_err_t
+miray_cmd_diag_bios_print_hdextinfo (grub_command_t cmd __attribute__ ((unused)),
+		       int argc, char **args )
+{
+  int version;
+  int drive;
+  const char *version_str;
+  struct grub_biosdisk_drp *drp
+        = (struct grub_biosdisk_drp *) GRUB_MEMORY_MACHINE_SCRATCH_ADDR;
+
+  struct grub_bios_int_registers hdversion_regs =
+  {
+    .eax = 0x4100,
+    .ebx = 0x55aa,
+  };
+
+  struct grub_bios_int_registers hdinfo_regs = 
+  {
+    .eax = 0x4800,
+    .esi = (unsigned long)drp & 0xf,
+    .ds = ((unsigned long)drp >> 4) & 0xffff,
+  };
+
+  if (argc < 1)
+    return grub_error(GRUB_ERR_BAD_ARGUMENT, "no harddrive specified");
+
+  drive = driveno(args[0]);
+  if (drive < 0)
+    return grub_error(GRUB_ERR_UNKNOWN_DEVICE, "invalid drive name");
+  hdversion_regs.edx = drive & 0xff;
+
+  grub_bios_interrupt (0x13, &hdversion_regs);
+  // version = grub_biosdisk_check_int13_extensions(drive);
+
+  if (hdversion_regs.flags & GRUB_CPU_INT_FLAGS_CARRY)
+    return grub_error(GRUB_ERR_BAD_DEVICE, "Drive extensions not supported");
+
+  version = (hdversion_regs.eax & 0xff00) >> 8;
+  switch (version) 
+  {
+    case 0x01:
+      version_str = "1.x";
+      break;
+    case 0x20:
+      version_str = "2.0 / EDD-1.0";
+      break;
+    case 0x21:
+      version_str = "2.1 / EDD-1.1";
+      break;
+    case 0x30:
+      version_str = "EDD-3.0";
+      break;
+    default:
+      version_str = 0;
+      break;
+  }
+
+  if (version_str)
+    grub_printf("Drive extensions version = %s\n", version_str);
+  else
+    grub_printf("Drive extensions version = 0x%x\n", version);
+
+  grub_memset(drp, 0, sizeof(*drp));
+  drp->size = sizeof(*drp);
+  hdinfo_regs.edx = drive & 0xff;
+  grub_bios_interrupt(0x13, &hdinfo_regs);
+  // ret = grub_biosdisk_get_diskinfo_int13_extensions(drive, drp);
+
+  if (hdinfo_regs.flags & GRUB_CPU_INT_FLAGS_CARRY)
+    return grub_error(GRUB_ERR_BAD_DEVICE, "fetching diskinfo extensions failed");
+
+  hexdump (0, (char *)drp, drp->size);   
+
+  grub_printf("size = 0x%x\n", drp->size);			// u16
+  grub_printf("flags = 0x%x\n", drp->flags);			// u16
+  grub_printf("C/H/S = %d/%d/%d\n", drp->cylinders, drp->heads, drp->sectors); // u32/u32/u32
+  grub_printf("total_sectors = %" PRIuGRUB_UINT64_T "\n", drp->total_sectors);
+  grub_printf("bytes_per_sector = %d\n", drp->bytes_per_sector);
+
+  if (version >= 0x20 && version < 0x30)
+  {
+    grub_printf("configuration parameters = 0x%x\n", drp->EDD_configuration_parameters);
+  }
+  else
+  {
+    hexdump (0x20, (char *)drp + 0x20, drp->length_dpi);   
+    grub_printf("device path info length = 0x%x\n", drp->length_dpi);;
+    grub_printf("name of host bus = %4s\n", drp->name_of_host_bus);
+    grub_printf("name of interface type = %8s\n", drp->name_of_interface_type);
+  }
+
+
+  return 0;
+}
+
+grub_err_t
+miray_cmd_diag_bios_print_cdinfo (grub_command_t cmd __attribute__ ((unused)),
+		       int argc, char **args )
+{
+  int ret;
+  struct grub_biosdisk_cdrp *cdrp
+        = (struct grub_biosdisk_cdrp *) GRUB_MEMORY_MACHINE_SCRATCH_ADDR;
+
+  struct grub_bios_int_registers cdinfo_regs = 
+  {
+    .eax = 0x4b01,
+    .esi = (unsigned long)cdrp & 0xf,
+    .ds = ((unsigned long)cdrp >> 4) & 0xffff,
+  };
+
+  if (argc < 1)
+  {
+    grub_printf("drive missing\n");
+    return -1;
+  }
+
+  ret = driveno(args[0]);
+  if (ret < 0)
+  {
+    grub_printf("invalid drive name\n");
+    return -1;
+  }
+  cdinfo_regs.edx = ret & 0xff;
+
+  grub_memset (cdrp, 0, sizeof (*cdrp));
+
+  cdrp->size = sizeof (*cdrp);
+  cdrp->media_type = 0xFF;
+  
+  //ret = grub_biosdisk_get_cdinfo_int13_extensions (drive, cdrp);
+  grub_bios_interrupt (0x13, &cdinfo_regs);
+  ret = cdinfo_regs.eax;
+  grub_printf("grub_biosdisk_get_cdinfo_int13_extensions ret = %d\n", ret);
+
+
+  if (ret == 0)
+  {
+
+    grub_printf("size = %d\n", cdrp->size);			// u8
+    grub_printf("media_type = 0x%x\n", cdrp->media_type );	// u8
+    grub_printf("drive_no = %s%d\n", cdrp->drive_no & 0x80 ? "hd": "fd", cdrp->drive_no & 0x7f);		// u8
+    grub_printf("controller_no = %d\n", cdrp->controller_no);	// u8
+    grub_printf("image_lba = %d\n", cdrp->image_lba);		// u32
+    grub_printf("device_spec = %d\n", cdrp->device_spec);	// u16
+    grub_printf("cache_seg = %d\n", cdrp->cache_seg);		// u16
+    grub_printf("load_seg = %d\n", cdrp->load_seg);		// u16
+    grub_printf("length_sec512 = %d\n", cdrp->length_sec512);	// u16
+    grub_printf("C/H/S = %d/%d/%d\n", cdrp->cylinders, cdrp->sectors, cdrp->heads); // u8/u8/u8
+
+    hexdump (0, (char *)cdrp, cdrp->size);
+
+  }
+
+  return 0;
+    
+}
diff --git a/grub-core/miray/commands/diag_efi.c b/grub-core/miray/commands/diag_efi.c
new file mode 100755
index 0000000..01914ee
--- /dev/null
+++ b/grub-core/miray/commands/diag_efi.c
@@ -0,0 +1,120 @@
+/*
+ *  GRUB  --  GRand Unified Bootloader
+ *  Copyright (C) 2010-2012 Miray Software <oss@miray.de>
+ *
+ *  GRUB is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  GRUB is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with GRUB.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include "miray_cmd_diag.h"
+
+#include <grub/misc.h>
+#include <grub/mm.h>
+
+#include <grub/efi/efi.h>
+#include <grub/efi/disk.h>
+
+#include <grub/miray_lib.h>
+
+
+grub_err_t
+miray_cmd_diag_efi_print_image_path(grub_command_t cmd __attribute__((unused)), int argc __attribute__((unused)), char **args __attribute__((unused)))
+{
+   grub_efi_loaded_image_t *image = NULL;
+   char *device = NULL;
+
+   image = grub_efi_get_loaded_image (grub_efi_image_handle);
+   if (image == NULL)
+   {
+      grub_printf("get_loaded_image returned NULL\n");
+      return -1;
+   }
+
+   device = grub_efidisk_get_device_name (image->device_handle);
+   if (device == NULL)
+   {
+      grub_efi_device_path_t *dp;
+      grub_efi_device_path_t *subpath;
+      grub_efi_device_path_t *dp_copy;
+
+      dp = grub_efi_get_device_path (image->device_handle);
+      if (dp == 0)
+        return 0;
+      
+      dp_copy = miray_efi_duplicate_device_path(dp);
+      subpath = dp_copy;
+
+      while ((subpath = miray_efi_chomp_device_path(subpath)) != 0)
+      {
+         device = miray_efi_get_diskname_from_path(subpath);
+         if (device != 0) break;
+      }
+
+      grub_free(dp_copy);
+   }
+
+   grub_printf("loaded image path: %s\n", device);
+
+   grub_free(device);
+
+   return 0;
+}
+
+grub_err_t
+miray_cmd_diag_efi_print_device_path(grub_command_t cmd __attribute__((unused)), int argc, char **argv)
+{
+   grub_disk_t disk = NULL;
+   grub_efi_handle_t handle = NULL;
+   grub_efi_device_path_t *dp = NULL;
+
+   if (argc < 1) return -1;
+
+
+   disk = grub_disk_open(argv[0]);
+   if (disk == 0)
+   {
+      grub_printf("could not open disk %s\n", argv[0]);
+      return -1;
+   }
+
+   handle = grub_efidisk_get_device_handle(disk);
+   if (handle == 0)
+   {
+      grub_printf("could not get handle for %s\n", argv[0]);
+      return -1;
+   }
+
+   dp = grub_efi_get_device_path (handle);
+   if (dp == 0)
+   {
+      grub_printf("could not get device path for %s\n", argv[0]);
+      return -1;
+   }
+   
+   grub_efi_print_device_path(dp);
+
+   {
+      grub_efi_device_path_t *subpath;
+      grub_efi_device_path_t *dp_copy = miray_efi_duplicate_device_path(dp);
+      subpath = dp_copy;
+
+      while ((subpath = miray_efi_chomp_device_path(subpath)) != 0)
+      {
+         grub_efi_print_device_path(subpath);
+      }
+
+      grub_free(dp_copy);
+   }
+
+   return 0;
+}
diff --git a/grub-core/miray/commands/miray_cmd_diag.h b/grub-core/miray/commands/miray_cmd_diag.h
new file mode 100755
index 0000000..738605f
--- /dev/null
+++ b/grub-core/miray/commands/miray_cmd_diag.h
@@ -0,0 +1,34 @@
+/*
+ *  GRUB  --  GRand Unified Bootloader
+ *  Copyright (C) 2010-2012 Miray Software <oss@miray.de>
+ *
+ *  GRUB is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  GRUB is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with GRUB.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef MIRAY_CMD_DIAG_H
+#define MIRAY_CMD_DIAG_H
+
+#include <grub/err.h>
+#include <grub/command.h>
+
+// BIOS only methods
+grub_err_t miray_cmd_diag_bios_print_hdextinfo (grub_command_t cmd, int argc, char **args );
+grub_err_t miray_cmd_diag_bios_print_cdinfo (grub_command_t cmd, int argc, char **args );
+
+// EFI methods
+grub_err_t miray_cmd_diag_efi_print_image_path(grub_command_t cmd, int argc, char **args);
+grub_err_t miray_cmd_diag_efi_print_device_path(grub_command_t cmd, int argc, char **args);
+
+
+#endif
-- 
1.9.2.msysgit.0

